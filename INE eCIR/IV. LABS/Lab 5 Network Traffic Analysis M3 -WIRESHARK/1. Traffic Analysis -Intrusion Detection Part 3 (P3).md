# ICMP Tunneling: P-Tunneling:  

## Lab File: 
![[Pasted image 20250929091735.png]]

![[Pasted image 20250929092041.png]]
Abnormal behaviour is highlighted above (Comments in Red Boxes) 
-> Num(Echo Request) <> Num(Echo Replies).
-> ICMP Payloads Size is way bigger than the usual legitimate ICMP payloads. 

Let's get deeper, first download ptunnel and then, open the ptunnel.h file using a text editor.
Around line #191, you will identify that the ptunnel header begins with a magic number, a short unique sequence of bytes that lets the recipient know that the ICMP payload should be treated as ptunnel traffic. This magic number is **``0xD5200880``** by default

![[Pasted image 20250929092125.png]]

Let's re-check the data section in our packets 
![[Pasted image 20250929092357.png]]

It looks like all ICMP packets of this capture file include the previously mentioned ptunnel magic value (0xD5200880), inside the ICMP payload.
![[Pasted image 20250929092648.png]]
As we can see, there are indications that a whole session, between an attacker and a compromised machine, is being concealed through ICMP traffic (ICMP tunneling)

The fact that a whole session, between an attacker and a compromised machine, is being concealed through ICMP traffic (ICMP tunneling) can be also identified by using the strings Linux command against the capture file as follows.
`` # strings ptunnel.pcap
![[Pasted image 20250929092801.png]]


# SMB Suspicious Activities
![[Pasted image 20250929103554.png]]

SMB works in a client-server model, where the client makes specific requests to the server, and based on the requests, the server responds accordingly. Most of the requests are related to accessing filesystems, while other forms of requests involve InterProcess Communication (IPC). Code 0 means STATUS_OK, which implies that everything works fine and there is no problem. Any other code should be examined.

Here are some SMB errors you should examine: 
![[Pasted image 20250929103631.png]]


Certain versions of Windows allowed for anonymous and passwordless authentication. Such a connection is often referred to as a NULL session. A NULL session may be limited in terms of privileges, but it could be used to execute various RPC calls and subsequently perform information gathering or user enumeration: 
![[Pasted image 20250929103848.png]]
As we can see traffic generated by Nmap’s smb-enum-users script. Notice the successful attempt to identify if a NULL session is possible. Also notice the RPC calls inside the subsequent rectangles, that were run to provide the attacker with a user list.

# HTTP Suspicious Activities
![[Pasted image 20250929103959.png]]

## Normal HTTP Traffic: 
![[Pasted image 20250929104038.png]]

We are seeing 6 packets (4 relating to TCP and 2 relating to HTTP:
	• Packets 3-6 is the TCP Handshake. HTTP relies on TCP for reliability.
	• Packet 7 we notice a HTTP method (GET).
	• Packet 9 we notice a HTTP response code (200 OK)


![[Pasted image 20250929104155.png]]
Here, we’re looking at the HTTP section of the packet details. The HTTP method is GET and the host is not in FQDN format. The http://IP format should alarm you, but in this case its pointing to an internal server and that is normal behavior in corporate environments. The source host has an IP of 10.54.15.100.

If we double click the link, [Response in frame: 9], in the HTTP section of the packet details of packet 7 we’ll jump to packet 9 which contains the packet details of the HTTP response to the HTTP request.
![[Pasted image 20250929104235.png]]
How many TCP streams are there in the packet capture below?
**Select Statistics -> Conversations and then click the TCP tab.**
![[Pasted image 20250929104837.png]]
Another way this can be done is by using a display filter and increment the number of the TCP Stream. You will identify a non-valid TCP Stream by the non-visible packets.
![[Pasted image 20250929104819.png]]
## Suspicious HTTP Traffic:
![[Pasted image 20250929105624.png]]
Glancing further at the capture file, a few packets down, we can see more indications of SQL injection attempts. Looking at packets #32 and #44 we can see that the person didn’t make a typo request at packet #20. This is indeed an attempt to find SQL injection on the server.

Now knowing that the individual is conducting SQL injection queries against the server, is he/she doing this manually or by using a tool?
![[Pasted image 20250929105752.png]]
Let's verify by checking the user-agent from packet (31) and (44): 
![[Pasted image 20250929105852.png]]

Back to packet (20): We can look at the Line-based text data: text/html portion of the packet details and notice that error messages are being displayed to the individual conducting the SQL injection queries.
![[Pasted image 20250929105954.png]]

Strangely, packet (56), don’t seem to contain any SQL injection queries. Maybe the individual decided not to continue the attack?
![[Pasted image 20250929110149.png]]

Let’s take a closer look at packet #56. Indeed no SQL injection attempt is visible within this packet, but something else should have already alarmed us, the User-Agent. The User-Agent for this HTTP GET Request is Sqlmap. So the attacker didn’t quit, he/she escalated
![[Pasted image 20250929110045.png]]


# HTTPS Suspicious Activities
![[Pasted image 20250929110214.png]]
## Normal HTTPS Traffic: 
![[Pasted image 20250929110525.png]]
• When analyzing HTTPS traffic, we should see encrypted packets. All traffic on port 443 should look this way.


![[Pasted image 20250929110558.png]]
As you may remember, the Secure Sockets Layer portion of the packet details should not be empty. Here we see pertinent info as to what the client has available in order to attempt to establish secure communications with the server, Client Hello packet. We see the following: 
• Content Type = Handshake 
• Handshake Protocol: Client Hello 
• Version: TLS 1.2 • Cipher Suites (11 suites) 
• Compression Method (1 method)



Here is the server’s response, Server Hello packet. These Hello messages again will contain the availability and agreement of encryption algorithms to work with and exchange of random values that will be used for generation of key.
![[Pasted image 20250929110643.png]]


Here we see the Server Key Exchange which will be followed by the Client Key Exchange packet. This will be considered step #3 in the establishment of an SSL/TLS session between a server and a client.
![[Pasted image 20250929110723.png]]

This is the last packet and the handshake between the server and client is now complete. The rest of the packets between these two devices will now be encrypted: 
![[Pasted image 20250929110742.png]]

The traffic is unreadable, but if this is internal traffic within our corporate environment, then, it is feasible to decrypt this traffic using the private key from the internal server.
![[Pasted image 20250929111303.png]]

## Malicious HTTPS Traffic
### Lab File
![[Pasted image 20250929113242.png]]
• When it comes to SSL/TLS handshakes, you should remember two things: 
	o Each SSL/TLS handshake is effectively a new connection (consuming resources) 
	o SSL/TLS handshakes are quite CPU intensive operations (server-side)

![[Pasted image 20250929113832.png]]
The **server’s reaction** to stop one abusive session ==(multiple Client Hello requests)

Normal SSL/TLS Handshake
- A **ClientHello** is normally sent once at the beginning of a session to initiate the SSL/TLS handshake.
- After the handshake (ServerHello, key exchange, ChangeCipherSpec, Finished), the session should proceed with encrypted application data.    
- Occasionally, renegotiation can happen for **legitimate reasons** (e.g., refreshing keys, requesting a client certificate). But it is **rare** in typical traffic.

![[Pasted image 20250929113211.png]]
**Renegotiation Sequence**:  
We see:
- `ClientHello` → `ServerHello` → `Certificate` → `ServerHello Done` → `Client Key Exchange` → `Change Cipher Spec` → `Encrypted Handshake Message`.
- Then immediately another **ClientHello** starts again, **without application data being exchanged**.


SSL/TLS renegotiation is a **legitimate feature**, but attackers abuse it by:
1. Continuously sending renegotiation requests (many `ClientHello` packets).
2. Forcing the server to perform resource-intensive handshakes repeatedly.
3. Leading to **resource exhaustion (CPU-bound DoS attack)**.

Taking into consideration both the above, it looks like we are dealing with a **SSL Renegotiation Attack**.