# SYN Scan Detection: 3 Ways Handshake Abuse

## Lab File: 
![[Pasted image 20250925160316.png]]

One of the ways using which the venerable Nmap tool tries to perform OS fingerprinting, is by examining the Initial Sequence Numbers (ISNs) generated by the target host (after connections are being attempted to a listening port). Each TCP/IP stack (and subsequently each OS) features its own way of generating Initial Sequence Numbers.

![[Pasted image 20250925111445.png]]

More specifically, Nmap sends a series of SYN packets to an open port and tries to perform OS fingerprinting, by attempting to identify the ISN generation formula in the returned SYN/ACK and comparing the returned values to a file that contains expected returned values for a series of checks.

Normal: 
SYN -> SYN-ACK -> ACK
10 / 11-20 / 21
![[Pasted image 20250925112308.png]]

Abnormal:
SYN / SYN / SYN / SYN 
![[Pasted image 20250925113916.png]]
- The first thing you should notice, is the big amount of SYN packets being sent to the 192.168.1.2 host (in a short amount of time and without the corresponding SYN/ACK packets).
- If you also carefully analyze the series of SYN packets that Nmap sent, you will notice something weird. Nmap repeatedly used the ISN from the scanning host, while scanning the different ports of the remote host. Unique ISNs should be used, while attempting to connect to different ports of a remote host.
- Once you identify a scanning host, you can determine if you are dealing with Nmap, by noting the scanning host’s ISN and executing the below.
`` # tcpdump -S -r nmap_sequence_number_prediction.pcap tcp[4:4] = $REPETITIVE_SEQ_NUMBER``

** In our case  ``$REPETITIVE_SEQ_NUMBER`` = 0 **
![[Pasted image 20250925114016.png]]--> The scanning host’s ISN reuse, indicates that the scanning/fingerprinting attempt most probably originates from a Nmap instance

# Source Port Abnormalities Detection
## Lab File: 
![[Pasted image 20250925160327.png]]
![[Pasted image 20250925161421.png]]

Let's apply the following filter to investiagte the suspicious endpoint's TCP Stream: 
``ip.addr == 192.168.1.6``
![[Pasted image 20250925161715.png]]--> You will notice that the host 192.168.1.6 uses the same source port (36901) for multiple connection attempts to different ports of the remote host. 
--> This is abnormal. The normal behavior would be incrementing the source port numbers inside the ephemeral port range.

# Destination Port Abnormalities Detection
## Lab File: 
![[Pasted image 20250925161929.png]]

![[Pasted image 20250925161957.png]]
--> We're dealing with a scanning attempt.
--> Destination port 0 (TCP): A host is not supposed to be listening on port 0. A scanning tool sending packets to port 0 (TCP) of the remote host, is trying identify if the remote host is alive. 
--> If alive,  an RST response should be sent to all those packets.

Note: 
For a successful RST attack to be executed, an attacker should have prior knowledge of the below.
	• Source Port
	• Destination Port
	• Source IP
	• Destination IP
	• “correct” Sequence Number

# TCP RST Attack Detection
## Lab File: 
![[Pasted image 20250925162559.png]]

(1): Don't ignore any highlight in RED conversation in wireshark (check the packets before and after it) ; Let's double click on Packet (12) and understand whats happening: 
![[Pasted image 20250926093547.png]]

(2):
![[Pasted image 20250926144057.png]]
- Normally, TCP uses the **FIN/FIN-ACK** sequence for a graceful close.
- An **RST** tells the other host to immediately stop using that connection.

2 possibilities are present in our case: 
- 1st: If this RST is legitimate (e.g., application crashed, port closed, connection invalid), then it’s just normal TCP behavior.
- 2nd: if an attacker is spoofing packets with RST flags, they can **forcibly tear down sessions** between two communicating systems. This is known as a **TCP RST Injection Attack** or **TCP Reset Attack**.

How to verify ? Let's take a look at the packet (11):
Packet (11) MAC:
![[Pasted image 20250926144609.png]]
Packet (12) MAC:
![[Pasted image 20250926144456.png]]
--> Packet **11** MAC ends `:8d`, packet **12** MAC ends `:aa`

Conclusion: packet 11 and packet 12 show different source MACs while referring to the same IP, this is **suspicious** and consistent with a **TCP RST injection**.

# TCP Session Hijaking Attack Detection
## Lab File:
![[Pasted image 20250926150003.png]]
NOTE: 
Know the difference between spoofing and hijaking: 
- **Spoofing:** Alice and Bob are communicating, and a rogue Alice (Attacker) appears on the network to communicate with Bob **while the original Alice is still present**.
    
- **Hijacking:** Alice and Bob are communicating, but a rogue Alice (Attacker) takes over the communication with Bob **after the original Alice is no longer active** -> Attacker has fully stolen the session (e.g., TCP session hijacking)

To conclude: 
- **Spoofing = impersonation while the real user still exists.**
- **Hijacking = attacker seizes control, and the real user is pushed out/ignored.**
![[Pasted image 20250926150246.png]]![[Pasted image 20250926150300.png]]
![[Pasted image 20250926150326.png]]
Let’s analyze packet (15):
- TCP Retransmission is displayed because the sequence number and the acknowledgement number of this packet are the same as the ones in packet #11.
- The MAC address of the client (192.168.1.4) in this packet is different than the MAC address that is included in all previous packets related to this host.

Let's analyse packet (16):
![[Pasted image 20250926151447.png]]
**D-SACK (Duplicate SACK):**
- The host is reporting that it received a duplicate segment (it got the same sequence number more than once).
- This is a key sign that **two different senders are injecting packets with the same sequence numbers**.
**SEQ/ACK Analysis:**
- It is acknowledging a packet that was not captured (maybe because injection occurred quickly).

From the D-SACK only we can confirm that the **victim host reporting duplicate/forged packets**: a classic indicator of **TCP session hijacking in progress**.

The attacker injected packets with overlapping sequence numbers, causing the receiver to acknowledge duplicate data.
![[Pasted image 20250926150957.png]]
The server has no defense mechanism to detect that the Telnet session is hijacked and sends the output of the uname -a command back to the 192.168.1.4 client
Packet (17):
![[Pasted image 20250926161249.png]]
Packet (20):
![[Pasted image 20250926161338.png]]