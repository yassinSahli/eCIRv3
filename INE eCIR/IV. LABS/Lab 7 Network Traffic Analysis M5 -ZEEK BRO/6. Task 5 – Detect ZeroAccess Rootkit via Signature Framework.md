## **Objective**

Analyze the `ZeroAccess.pcap` file and use **Bro’s signature framework** to detect malicious traffic patterns associated with the **ZeroAccess rootkit**.

---

## **Background**

- ZeroAccess is a rootkit known for:
    
    - P2P communications (often on **UDP port 16464**).
        
    - Using XOR + rotation obfuscation to exchange IP lists.
        
    - Embedding unique fingerprints inside packet payloads.
        
- The example payload shows a distinctive pattern:
    
![[Pasted image 20250928000358.png]]
**Encrypted payload:**

`b8:14:35:fe:28:94:8d:ab:c9:c0:d1:99:85:95:6f:3f`

This **fingerprint** can be leveraged to build a **Bro signature**.

---

## **Step 1 – Create a Signature File**

First, create a new directory for the ZeroAccess detection scripts:

`cd ~ mkdir zeroaccess cd zeroaccess vim zeroaccess.sig`

Inside `zeroaccess.sig`, add:

`signature zeroaccess {     ip-proto == udp     payload /....\x28\x94\x8d\xab.*/     event "zeroaccess" }`

Explanation:

- **`ip-proto == udp`** → only match UDP traffic.
    
- **`payload /....\x28\x94\x8d\xab.*/`** → regex that identifies the unique ZeroAccess fingerprint in the packet.
    
- **`event "zeroaccess"`** → trigger an event when the signature matches.
    

---

## **Step 2 – Create a Bro Script for Detection**

Now, create the script to load the signature and raise alerts:

`vim zeroaccess.bro`

Inside, type:

`@load base/frameworks/notice @load base/frameworks/signatures/main @load base/utils/addrs @load base/utils/directions-and-hosts  @load-sigs ./zeroaccess.sig  redef Signatures::ignored_ids += /zeroaccess/;  module ZeroAccess;  export {     redef enum Notice::Type += {         ## Raised when a host does ZeroAccess-related activity         ZeroAccess_Client,         ZeroAccess_Server     };      ## Type of ZeroAccess host to alert on     const notice_zeroaccess_hosts = LOCAL_HOSTS &redef;     const zeroaccess_timeout = 60 mins &redef;      global zeroaccess_tracker: set[addr]; }  event signature_match(state: signature_state, msg: string, data: string) &priority=-5 {     if ( /zeroaccess/ !in state$sig_id ) return;      if ( state$conn$id$orig_h !in zeroaccess_tracker ) {         add zeroaccess_tracker[state$conn$id$orig_h];          NOTICE([             $note=ZeroAccess::ZeroAccess_Client,             $msg=fmt("Probably ZeroAccess P2P Client Access: "),             $sub=data,             $conn=state$conn,             $identifier=fmt("%s -> %s",                             state$conn$id$orig_h,                             state$conn$id$resp_h)         ]);     } }`

---

## **Step 3 – Run Bro with the Signature**

Execute Bro with the ZeroAccess signature and script:

`bro -C -b -r PCAPs/ZeroAccess.pcap zeroaccess/zeroaccess.bro`

- **`-C`** → ignore bad TCP checksums.
    
- **`-b`** → do not auto-load base scripts.
    
- **`-r`** → run in offline mode with PCAP.
    

---

## **Step 4 – Inspect Logs**

Check for generated alerts:

`cat notice.log`
![[Pasted image 20250928000449.png]]
You should see entries similar to:

`Probably ZeroAccess P2P Client Access: <details about host communication>`

This confirms that Bro successfully detected **ZeroAccess activity**.

---

## **Outcome**

- Built a **custom Bro signature** to detect ZeroAccess fingerprints.
    
- Confirmed ZeroAccess-related traffic in the `ZeroAccess.pcap` file.
    
- Detection is logged in **notice.log**, helping analysts identify compromised hosts.
    

---

✅ **Conclusion:** Bro’s **signature framework** enables precise detection of known malware fingerprints. In this task, we created a signature to identify **ZeroAccess rootkit traffic**, confirming the infection through **PCAP analysis**.