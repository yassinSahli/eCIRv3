## **Objective**

Analyze the `incident_1.pcap` file using Bro and identify **abnormal SSL activity** that may indicate **malware using SSL certificates for malicious purposes**.

---

## **Step 1 â€“ Run Bro on the PCAP**

Execute Bro against the provided PCAP file:

`bro -C -r PCAPs/incident_1.pcap local`

- **`-C`** â†’ ignore invalid TCP checksums.
    
- **`-r`** â†’ analyze traffic from a PCAP file.
    
- **`local`** â†’ load site-specific policies (`local.bro`).
    

ðŸ‘‰ No output will appear on screen, but multiple Bro log files will be created (e.g., `conn.log`, `weird.log`, `ssl.log`, `notice.log`).
![[Pasted image 20250927174904.png]]
---

## **Step 2 â€“ Inspect weird.log**

`weird.log` contains anomalies like malformed traffic or protocol violations.

`cat weird.log`

ðŸ‘‰ In this case, nothing conclusive is found. Move on.
![[Pasted image 20250927174944.png]]
---

## **Step 3 â€“ Inspect notice.log**

Check Broâ€™s notices for SSL-related issues:

`cat notice.log`

![[Pasted image 20250927230511.png]]

Observations:

- SSL traffic is seen on **port 4433 (non-standard)**.
    
- Messages about **self-signed certificates** appear.
    
- Some certificates contain suspicious **â€œdefaultâ€ values**.
    

âš ï¸ Note: While self-signed certificates are common, lazy or malformed certificates are often linked to malicious actors.

---

## **Step 4 â€“ Configure Bro to Extract SSL Certificates**

By default, Bro does not extract all certificates. Modify `local.bro`:

`sudo vim /opt/bro/share/bro/site/local.bro`

Append:

`@load protocols/ssl/extract-certs-pem redef SSL::extract_certs_pem = ALL_HOSTS;`

Now, rerun Bro:

`bro -C -r PCAPs/incident_1.pcap local`

![[Pasted image 20250927231840.png]]
ðŸ‘‰ A file named **`certs-remote.pem`** will be generated, containing all observed SSL certificates.

---

## **Step 5 â€“ Split Certificates into Individual Files**

Create a directory and split certificates into separate `.pem` files:

`mkdir temp mv certs-remote.pem temp cd temp  awk ' split_after == 1 {close(n".pem"); n++;split_after=0} \ /-----END CERTIFICATE-----/ {split_after=1} { print > n".pem"}' < certs-remote.pem`
![[Pasted image 20250927231911.png]]
ðŸ‘‰ You will now see `0.pem`, `1.pem`, `2.pem`, etc.

---

## **Step 6 â€“ Inspect Certificates with OpenSSL**

Check each certificate:

`openssl x509 -in 1.pem -text -noout`

Observations:

- One certificate shows an **unusually large X509v3 Subject Key Identifier**.
    
- The section contains **hexadecimal values** and **NULL bytes**.
    
- Starts with `4D5A`, which corresponds to `MZ` â€” the magic bytes of a **Windows executable (PE file)**.
    ![[Pasted image 20250927231946.png]]
![[Pasted image 20250927232052.png]]
---

## **Step 7 â€“ Extract the Hidden Payload**

1. Copy the entire **X509v3 Subject Key Identifier** section.
    
2. Clean it with `sed`:
    

`echo "PASTE-HERE" | sed 's/://g'`

3. Convert hex to binary:
    

`echo "CLEANED-HEX" | xxd -r -p`

![[Pasted image 20250927232129.png]]
ðŸ‘‰ The output reveals a **binary executable** hidden inside the SSL certificate.

---

## **Outcome**

- Malware was using SSL certificates to **smuggle a binary payload** inside the **X509v3 Subject Key Identifier** field.
    
- This technique bypasses naÃ¯ve inspection tools by disguising malware inside an otherwise valid SSL handshake.