#### **Scenario**: 
The organization you work for is considering deploying Snort to enhance its traffic inspection capabilities. Your IT Security manager tasked you with thoroughly analyzing Snort’s capabilities. He also provided you with PCAP files containing malicious traffic, so that you can experiment with writing Snort detection rules. A test instance of Snort has already been set up and waiting for you!

#### **Objectives**
The learning objective of this lab is to not only get familiar with the detection capabilities of Snort but to also learn effective writing of Snort rules. Specifically, you will learn how to use Snort’s capabilities in order to: 
- Have better visibility over a network 
- Respond to incidents timely and effectively 
- Proactively hunt for threats

#### **Introduction to SNORT**:
Snort is an open source IDS and IPS, that can also be used as a packet sniffer or packetlogger. Just like Suricata, Snort inspects all traffic on a link for malicious activity and canextensively log all flows seen on the wire, producing high-level situational awareness anddetailed application layer transaction records. It needs specific rules (holding instructions)to tell it not only how to inspect the traffic it looks at but also what to look for. It wasdesigned to perform on commodity and purpose-built hardware

The most important Snort features and capabilities are: 
	• Deep packet inspection 
	• Packet capture logging 
	• Intrusion Detection 
	• Network Security Monitoring 
	• Anomaly Detection 
	• Multitenancy 
	• IPv6 and IPv4 support

##### Common Snort operation modes:
- Inline IDS/IPS Mode:
![[Pasted image 20251007142010.png]]
- Passive IDS:
![[Pasted image 20251007142043.png]]
- NIDS & HIDS:
![[Pasted image 20251007142251.png]]

Here's a real life scenario: 
![[Part2.jpeg]]
A computer running Snort IDS/IPS has two ethernet interfaces, one is connected to a port on the switch, while the other is connected to the router.

##### Snort high-level architecture
![[Pasted image 20251007142530.png]]
For Snort to evolve from a packet sniffer into a full-fledged IDS, some components had tobe added. These components were the Preprocessor, the Detection Engine, the Logging andAlerting System, and the various Output modules.

	• The packet sniffer (including the Packet Decoder), as its name suggests, “sniffs”network traffic and identifies each packet’s structure (layer information). The rawpackets that have been “collected” are then sent to the Preprocessors.

	• The Preprocessors determine the type or the behavior of the forwarded packets.Inside Snort, there are numerous Preprocessor plugins. An example of such a pluginis the HTTP plugin which is responsible for identifying HTTP-related packets.Another example is the sfPortscan Preprocessor that, armed with defined protocols,types of scans and certain thresholds, can identify a group of packets as a port scanattempt. Once the Preprocessors cease their operations, information is sent to theDetection Engine.
	
	• The Detection Engine is responsible for comparing each packet with each Snort rule(from a predefined rule set). In case of a match, information is sent to the Loggingand Alerting System.

	• The Logging and Alerting System as well as the various Output modules areresponsible for logging or triggering alerts based on each rule action. Logs arestored in different formats (most of the times syslog or unified2) or directly into aDB. Output modules are configured through Snort’s configuration file snort.conf.Example:output alert_syslog: host=192.168.2.10:514, <facility> <priority><options>output alert_syslog: host=192.168.2.10:514, log_auth log_alertlog_ndelayIn the case of syslog being used, alerts will be visible in /var/log/message.



#### **Network Configuration**
Incident Responder’s Subnet: 172.16.66.0/24
BRO: 172.16.71.100
- Under-investigation endpoints’ subnet: 10.100.11.0/24
• Connection Type: SSH
o Use a Linux or Windows SSH client to connect to Bro (172.16.71.100), as follows
▪ Username: elsuser <- Root-level access
▪ Password: GwoZbb3B
``ssh elsuser@172.16.71.100

All provided PCAPs are inside the /home/elsuser/PCAPs directory. They can be transferred
to the machine, from inside which you connected to this lab as follows.
![[Pasted image 20251007163341.png]]
Now, you can simply launch a browser of your choice inside the machine from which you
connected to this lab and browse to http://172.16.71.100 to download the provided PCAP
files.
![[Pasted image 20251007163420.png]]
#### Task 1: WRITE A SNORT RULE THAT DETECTS AN ICMP ECHO REQUEST (PING) OR ECHO REPLY MESSAGE

REF: http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node27.html
The main config file is usually: ``/etc/snort/snort.conf``


Context: 
An icmp.pcap PCAP file exists inside the /home/elsuser/PCAPs directory that contains ICMP
traffic towards the network subnet you are protecting (192.168.1.0/24).

Introduce a Snort rule into its local.rules file that detects an ICMP Echo request (ping) or
Echo reply message towards your organization’s subnet (192.168.1.0/24).

Snort’s default snort.conf already contains the 192.168.1.0/24 subnet inside the HOME_NET
variable. No changes need to be made.

Once you are connected to the deployed Snort instance over SSH, you can introduce a new
Snort rule as follows.

``# sudo vim /etc/nsm/rules/local.rules
[!] The main config file is usually: ```/etc/snort/rules/local.rules``` [!]
##### Workload
Inside vim enter the following rule that is able to detect an ICMP Echo request (ping) or
Echo reply message: 

``alert icmp any any -> $HOME_NET any (msg: "ICMP test"; sid:1000001; rev:1; classtype:icmp-event;)

Detailed Explanation 
- alert – Rule action. When the specified condition is observed on the wire, Snort will throw an alert.
- icmp – Protocol to inspect (matches IPV4 ICMP)
- any – Source IP. Snort will consider all source addresses.
- any – Source port. Snort will consider all source ports -> – Indicates directionality.
- $HOME_NET – Destination IP. We are leveraging the HOME_NET variable specified in the snort.conf file which is 192.168.1.0/24
- any – Destination port. Snort will consider all ports of our network.
- msg:"ICMP test" – Message that will accompany the alert.
- sid:1000001 – Snort rule ID. Remember all IDs smaller than 1,000,000 are reserved.
- rev:1 – Revision number (versionning)
- classtype:icmp-event – Used for rule categorization
![[Pasted image 20251007165403.png]]
![[Pasted image 20251007165926.png]]
Then, instruct Snort to update its rule set. Inside Security Onion you can do that as follows: 
``# sudo rule-update
![[Pasted image 20251007164800.png]]

Finally, let's test out our rule by replaying the icmp.pcap file towards the eth0 interface (the one Snort monitors), to see if any alerts will be triggered.
``# sudo tcpreplay -t -i eth0 PCAPs/icmp.pcap
![[Pasted image 20251007165026.png]]

To see if any alerts were triggered you can use a web UI called Squert. Launch any browser, navigate to https://172.16.71.100/squert/login.php and submit the credentials you used to SSH into the Bro instance (username: elsuser, password: GwoZbb3B).
![[Pasted image 20251007170306.png]]
If you don’t see any alerts (and you are sure you entered the rule correctly) make sure you are viewing the alerts of the correct date.
Before you continue, clear the current events in the Sguil database:
``# sudo sguil-db-purge

If you don’t like watching alerts on a web UI, you can execute the below, which will output any alerts on the standard output.
``# sudo snort -q -A console --daq pcap -c /etc/nsm/securityonion-eth0/snort.conf -r PCAPs/icmp.pcap
![[Pasted image 20251007165847.png]]

#### Task 2: ANALYZE THE PROVIDED PCAP FILE AND WRITE SNORT RULES TO DETECT SUCCESSFUL BUFFER OVERFLOW ATTACKS

REF: http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node27.html
[!] The main config file is usually: ```/etc/snort/rules/local.rules``` [!]

##### Context: 
Now it’s time to write your own Snort rules. Analyze the eternalblue.pcap PCAP file (stored
in the /home/elsuser/PCAPs directory) using tcpdump. 

This PCAP file includes network traffic of an exploitation attempt, against a Windows 7 host, that leveraged the notorious Eternal Blue exploit and resulted in the attacker obtaining Windows shell access.

In plain terms, the authors of the Eternal Blue exploit identified that the Windows SMBv1 implementation is vulnerable to buffer overflow. The Eternal Blue exploit received immense attention, and consequently, numerous rules (including Snort ones) have been written to detect it on the wire. 

For this reason, write a Snort rule that detects:
• The buffer overflow portion of the traffic, and
• The windows shell access that the attacker gained

##### Hint: 
Refer to the included cert_trafficwireshark.pdf resource, “6. FOLLOW TCP STREAM” section, to see how buffer overflow attacks look like on the wire. Specifically, notice all those "A" characters that facilitate the buffer overflow.

##### Workload
Let’s start our analysis by executing tcpdump as follows.
``# sudo tcpdump -nnttttAr eternalblue.pcap

- -nn is used so that tcpdump doesn’t resolve hostnames or port names
- -tttt is used so that we are provided with the maximal human-readable timestamp output
- -A is used so that tcpdump prints each packet (minus its link level header) in ASCII

Starting from the bottom up, you should see something similar to the below image.
![[Pasted image 20251008081109.png]]
The infinite "AAAAA..." string is called an **Injection Point** = Buffer Overflow.

The above looks quite similar to what you saw inside the included cert_trafficwireshark.pdf resource in the 6. FOLLOW TCP STREAM section. 

In this case, the buffer overflow attempt happens over SMB (notice the 445 port). 

Let’s use this buffer overflow-related portion of the traffic to create our rule. We can do that as follows.
``# echo "copy-paste all the As here" | wc -m``
![[Pasted image 20251007171156.png]]
--> 1389 'A
It is more efficient to specify the rule content in hex. Let’s turn the above into hex as follows (A is 41 in hex)
``# python -c 'print ("41" * 1389)'
![[Pasted image 20251007171250.png]]
Now, copy all the 41s and create a Snort rule that will detect buffer overflow attempts (in this case over SMB), as follows.
``# sudo vim /etc/nsm/rules/local.rules

Inside vim enter the below.
``alert tcp $EXTERNAL_NET any -> $HOME_NET 445 (msg:"Buffer overflow activity over SMB"; content:"|paste all 41s here|"; sid:1000002; rev:1;)

You should see something similar inside the local.rules file
![[Pasted image 20251007171406.png]]

Let’s put the rule above to the test, as follows
```
# cd ~
# sudo rule-update
# sudo snort -q -A console --daq pcap -c /etc/nsm/securityonion-eth0/snort.conf -k none -r PCAPs/eternalblue.pcap
```
- -k is used to disable Snort’s entire checksum verification subsystem

![[Pasted image 20251007171812.png]]

#### Task 3: ANALYZE THE PROVIDED PCAP FILE AND WRITE A SNORT RULE TO DETECT POSSIBLE HEARTBLEED EXPLOITATION ATTEMPTS

REF: http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node27.html
REF: This PCAP was taken from: https://asecuritysite.com/forensics/snort
[!] The main config file is usually: ```/etc/snort/rules/local.rules``` [!]

**Heart Beat Attack: CVE-2014-0160**
- Extension: **TLS Heartbeat (RFC 6520)**
- Implemented in OpenSSL 1.0.1 – 1.0.1f (inclusive)
- Purpose: keep TLS connections alive without renegotiation
- Highlights: a bug in OpenSSL's TLS heartbeat that lets an unauthenticated attacker read chunks of server memory (potentially leaking keys/credentials) by requesting more data than was sent.

In the vulnerable OpenSSL code (`tls1_process_heartbeat()`), the library **did not validate** that `payload_length` actually matched the length of data received from the client.

So, an attacker could send:

- **Payload_length = 0x4000 (16 KB)**
    
- **Actual payload = few bytes (e.g. “A”)**
That “extra” data comes from **heap memory** adjacent to the heartbeat buffer  ==leaking whatever was there: session IDs, usernames, cookies, private keys, etc.==

Consequences: 
- Remote memory disclosure (read-only).
- No crash, no authentication required.
- Leakage of up to 64 KB per request.
- Repetition yields significant data from the heap (stack, session cache, even `ssl_private_key`).
##### Context:
Analyze the heart.pcap PCAP file (stored in the /home/elsuser/PCAPs directory) using Wireshark. Then, try to identify how you can instruct Snort to detect possible Heartbleed exploitation attempts and finally, write a Snort rule.

Note that exploitation of this vulnerability leaves no traces since it takes place inside the SSL handshake negotiation. The SSL handshake negation occurs before the listening service receives the request. Subsequently, you won’t be able to see any revealing log in the backend. Traffic analysis is your only choice.

##### Hint: 
Refer to the included “A technical view of theOpenSSL Heartbleed vulnerability.pdf”
resource, to learn more about the Heartbleed vulnerability.

##### Workload
By reading the “A technical view of theOpenSSL Heartbleed vulnerability” resource, it is clear that we need to focus our attention on any Heartbeat-related traffic.

Let’s open heart.pcap in Wireshark and filter the traffic in order to see only encrypted Heartbeat messages. We can do that as follows.
``ssl.record.content_type == 24
![[Pasted image 20251007172724.png]]


If you look carefully enough, 40 00 is the equivalent of 16384 in decimal. 
![[Pasted image 20251007172739.png]]
Specifically, the attacker specified that the payload length is 16384 bytes, but no additional data were actually sent.  According to the Heartbleed vulnerability, if the server is vulnerable, it
should send more data than it typically should.
![[Pasted image 20251008081041.png]]
This is the case because the Heartbeat response is 16384 bytes long.
We can create an unreliable Snort rule based on the Heartbeat request above, as follows.
``# sudo vim /etc/nsm/rules/local.rules

Inside vim enter the below
``alert tcp $EXTERNAL_NET any -> $HOME_NET 443 (msg:"Potential Heartbleed attack"; flow:to_server,established; content:"|18 03 02 00 03 01 40 00|"; rawbytes; isdataat:!1,relative; sid:1000004; rev:1;)

Let’s put the rule above to the test as follows.
```
# cd ~
# sudo rule-update
# sudo snort -q -A console --daq pcap -c /etc/nsm/securityonion-eth0/snort.conf -k none -r PCAPs/heart.pcap
```

![[Pasted image 20251007173603.png]]

The rule above is unreliable because it is constructed to match the exact Heartbeat request in the PCAP. The attacker could specify a payload length different than 16384 bytes and also use another TLS version.

For this reason, we can create a more reliable Snort rule that detects suspiciously large
Heartbeat responses, as follows.
``alert tcp $EXTERNAL_NET any -> $HOME_NET 443 (msg:"Potential Heartbleed attack – Response-based"; flow:to_server,established; content:"|18 03|"; rawbytes; depth:2; byte_test:1, &, 3, 0, relative; byte_test:2, >, 200, 3, relative, big; sid:1000005; rev:1;)``

- byte_test:1, &, 3, 0, relative;
- relative: Use an offset relative to the last pattern match
- 0: Start from the first position within the packet (first byte)
- 1: The number of bytes to take from the position “0” (first position)
- &: Perform a binary “bitwise AND” operation to test the value
- 3 : Value to test the converted value against
- big: Process data as big endian (default

The first byte_test is related to the TLS version used, whereas the second byte_test checks if
the length is suspiciously large. Refer to the below image to comprehend which bytes are
being checked. The first byte_test checks what is inside the red rectangle, whereas the
second byte_test checks what is inside the blue rectangle.
![[Pasted image 20251007173740.png]]

#### Task 4: ANALYZE THE PROVIDED SNORT RULE AND DESCRIBE WHAT IT LOOKS FOR

REF: http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node27.html
[!] The main config file is usually: ```/etc/snort/rules/local.rules``` [!]


##### Context: 
Armed with the knowledge you obtained so far regarding Snort rules, analyze the Snort rule below and describe what it looks for.

``alert tcp $EXTERNAL_NET any -> $HOME_NET 445 (msg:"NETBIOS SMB-DS DCERPC LSASS DsRolerUpgradeDownlevelServer exploit attempt"; flow:to_server,established; flowbits:isset,netbios.lsass.bind.attempt; content:"|FF|SMB"; depth:4; offset:4; nocase; content:"|05|"; distance:59; content:"|00|"; within:1; distance:1; content:"|09 00|"; within:2; distance:19; classtype:attempted-admin; sid:2514; rev:7;)``

## Rule header

- `alert` — action: generate an alert (log it). Does **not** block traffic.
- `tcp` — protocol: TCP.
- `$EXTERNAL_NET any` — source: any host in the external network variable, any source port.
- `->` — direction: from source **to** destination (unidirectional).
- `$HOME_NET 445` — destination: any host in HOME_NET on TCP port **445** (SMB over TCP).
**Interpretation:** this rule watches SMB (NetBIOS-less SMB) traffic _to_ internal hosts on port 445.

## Rule options — broken down

### `msg:"NETBIOS SMB-DS DCERPC LSASS DsRolerUpgradeDownlevelServer exploit attempt";`

Human-readable message inserted into alerts. It indicates the rule authors intended to detect an exploit targeting a DCERPC/LSASS-related RPC endpoint (DsRole*), likely an attempt to exploit remote procedure calls that touch LSASS or domain controller role APIs.

### `flow:to_server,established;`

Match only packets within an **established TCP session** and flowing **to the server** (i.e., from client → server). This avoids matching non-established or server→client packets.

### `flowbits:isset,netbios.lsass.bind.attempt;`

This rule **requires** a flowbit named `netbios.lsass.bind.attempt` to be previously **set** for this flow. Flowbits are used to tie multiple rules together — e.g., a preceding rule sets the flowbit when a suspicious DCERPC bind to LSASS is observed; this rule fires only after that condition was seen for the same connection. This reduces false positives and tries to ensure the attack is actually a relevant DCERPC/LSASS interaction.

### `content:"|FF|SMB"; depth:4; offset:4; nocase;`
- `content:"|FF|SMB"` checks for the ASCII bytes `0xFF 0x53 0x4D 0x42` (which is `\xFFSMB`), the SMB protocol signature used in SMB headers.
- `offset:4` means the match starts at byte offset 4 of the payload (skip the first 4 bytes — typical for NetBIOS Session Service header which is 4 bytes).
- `depth:4` limits the search to the first 4 bytes _after_ the offset (so it inspects bytes 4–7 effectively).
- `nocase` makes the ASCII match case-insensitive (not strictly necessary for `\xFFSMB` but harmless).
    

**Purpose:** detect an SMB packet (NetBIOS-less SMB over TCP uses a 4-byte NetBIOS length field followed by `\xFFSMB`).

### `content:"|05|"; distance:59;`

- Looks for a single byte `0x05` occurring **59 bytes after** the end of the previous content match.
- `distance:59` is relative to the end of the previous content match (so it navigates into the SMB header/parameters/SMB payload structure).
    

### `content:"|00|"; within:1; distance:1;`

- After finding `0x05` at the earlier offset, this requires the next match to be `0x00` **1 byte after** that (`distance:1`) and `within:1` ensures the `0x00` is within 1 byte (i.e., exact position).
- Combined `distance:1; within:1;` forces a concrete two-byte sequence at a specific SMB payload location relative to previous matches.
    

### `content:"|09 00|"; within:2; distance:19;`

- Then, **19 bytes after** the previous content, require the two-byte sequence `0x09 0x00`. `within:2` ensures the two bytes are contiguous.
- These successive `distance`/`within` constraints are walking fields inside an SMB/SMB-DS / DCERPC payload to match a particular RPC operation or structure expected in the exploit.
    
### `classtype:attempted-admin;`

Classification for logging and prioritization; indicates a high-severity action that attempts to gain administrative control.

### `sid:2514; rev:7;`
- `sid` (signature ID) uniquely identifies the rule. `2514` — important to avoid collisions.
- `rev` is the revision number of the rule (here `7`).


**This rule alerts on SMB (TCP/445) packets that match a precise DCERPC/LSASS RPC payload fingerprint **after** a detected LSASS/DCERPC bind attempt (via a flowbit), flagging a likely exploit attempt to abuse LSASS/DCERPC interfaces for administrative compromise.**

#### Well known Ready-To-Go Threat Rules
The latest Snort rules can be downloaded from https://rules.emergingthreats.net/open-nogpl/
[!] The main config file is usually: ```/etc/snort/rules/local.rules``` [!]
![[Pasted image 20251007161038.png]]
![[Pasted image 20251007161100.png]]